const fs = require('fs');
const path = require('path');
const util = require('util');

const [fsReaddir, fsReadFile, fsWriteFile] = [
  fs.readdir,
  fs.readFile,
  fs.writeFile,
].map(util.promisify);

/*
 * 対象にするディレクトリと、そのディレクトリ内からみた生成ファイルのパス
 */
const targetDirTable = {
  './src/error/': 'index.ts',
};

const defaultExportRegExp = /(?:^|[\r\n])export\s+default\s+class\s+([^\s{}]+)(?:\s+[^\s{}]+)*\s*\{/;
const typescriptExtRegExp = /\.ts$/;

const scriptFilepath = path.relative(process.cwd(), __filename);

/*
 * TypeScriptの拡張子かどうか判定する
 */
function isTsExt(filename) {
  return typescriptExtRegExp.test(filename);
}

/*
 * TypeScriptの拡張子を削除する
 */
function deleteTsExt(filename) {
  return filename.replace(typescriptExtRegExp, '');
}

/*
 * currentFilepathから見たtargetFilepathの相対パスを取得する
 */
function filepathRelative(currentFilepath, targetFilepath) {
  return path.join(
    path.relative(path.dirname(currentFilepath), path.dirname(targetFilepath)),
    path.basename(targetFilepath),
  );
}

/**
 * 渡されたfs.Direntオブジェクトがファイルを示している場合に、パスの文字列へ変換する。
 * 文字列はそのまま返す。
 *
 * @param {string|fs.Dirent} pathOrDirent fs.Direntオブジェクト、または、ファイルパスの文字列。
 * @return {string|null} pathOrDirentがfs.Direntオブジェクトの場合は、
 *     ファイルを示すパスの場合に文字列。ファイル以外の場合にnull。
 *     pathOrDirentが文字列の場合は、判定できないためそのまま帰す。
 *     すなわち、nullなら確実にファイルではなく、文字列の場合はファイルではないパスの可能性がある。
 */
function toFilepath(pathOrDirent) {
  if (typeof pathOrDirent === 'string') {
    return pathOrDirent;
  }

  if (pathOrDirent.isFile()) {
    return pathOrDirent.name;
  }

  return null;
}

/**
 * ファイルの内容を取得する。対象がディレクトリの場合はnullを返す。
 * @param {string} filepath
 * @return {string|null} ファイルを開けた場合は内容。パスがディレクトリだった場合はnull
 * @throws {Error} 対象のパスを開けなかった場合は、fsのエラーをそのまま帰す。
 */
async function getFileContents(filepath) {
  try {
    return await fsReadFile(filepath, 'utf8');
  } catch (error) {
    if (error.code === 'EISDIR') {
      /*
       * 対象のパスがディレクトリの場合、nullを返す
       */
      return null;
    }
    throw error;
  }
}

/**
 * default export文に割り当てられた識別子を取得する
 * @param {string} fileContents スクリプトファイルの内容
 * @return {string|null} 識別子を取得できた場合はその文字列。取得できなかった場合はnull。
 */
function getExportName(fileContents) {
  const matchResult = defaultExportRegExp.exec(fileContents);
  return matchResult ? matchResult[1] : null;
}

async function generateIndexFile(dirpath) {
  /*
   * 対象のパスをディレクトリとして開けるか検証する
   */
  const filepathList = await fsReaddir(dirpath, { withFileTypes: true });

  const relativeDirpath = path.relative(process.cwd(), dirpath);
  const generateFilename = [
    targetDirTable[relativeDirpath],
    targetDirTable[`${relativeDirpath}/`],
    targetDirTable[`./${relativeDirpath}`],
    targetDirTable[`./${relativeDirpath}/`],
  ].find(Boolean);

  if (!generateFilename) {
    return;
  }

  const generateFilepath = path.resolve(dirpath, generateFilename);

  const exportNameList = (await Promise.all(
    filepathList
      .map(toFilepath)
      .filter(filepath => filepath && isTsExt(filepath))
      .map(filepath => path.resolve(dirpath, filepath))
      .map(async filepath => ({
        filepath,
        contents: await getFileContents(filepath),
      })),
  ))
    .filter(({ contents }) => contents !== null)
    .map(({ filepath, contents }) => ({
      filepath: deleteTsExt(filepathRelative(generateFilepath, filepath)),
      name: getExportName(contents),
    }))
    .filter(value => !!value.name);

  if (exportNameList.length > 0) {
    const generateFileRelativePath = filepathRelative(
      generateFilepath,
      __filename,
    );
    const exportCode = exportNameList
      .map(
        ({ filepath, name }) =>
          `export { default as ${name} } from './${filepath}';`,
      )
      .join('\n');
    const code = `// Code generated by ${generateFileRelativePath}\n\n${exportCode}\n`;

    await fsWriteFile(generateFilepath, code);
    // eslint-disable-next-line no-console
    console.log(`generated ${path.relative(process.cwd(), generateFilepath)}`);
  }
}

(async argv => {
  try {
    if (argv.length > 2) {
      const targetDirFullpath = path.resolve(argv[2]);

      try {
        await generateIndexFile(targetDirFullpath);
      } catch (error) {
        /*
         * targetDirFullpathがディレクトリのパスではない場合、現在のパスのディレクトリを参照する
         */
        if (error.code === 'ENOTDIR') {
          await generateIndexFile(path.dirname(targetDirFullpath));
        } else {
          throw error;
        }
      }
    } else {
      /*
       * 引数が少ない場合は、エラーを出して終了する
       */

      // eslint-disable-next-line no-console
      console.error(
        `${scriptFilepath} requires one argument: target directory path`,
      );
      // eslint-disable-next-line no-process-exit
      process.exit(1);
    }
  } catch (error) {
    // eslint-disable-next-line no-console
    console.error(`${scriptFilepath}: Error!`);
    // eslint-disable-next-line no-console
    console.dir(error);
    // eslint-disable-next-line no-process-exit
    process.exit(1);
  }
})(process.argv);
